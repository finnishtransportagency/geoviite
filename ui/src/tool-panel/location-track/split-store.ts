import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    DuplicateStatus,
    formatTrackName,
    getNameFreeText,
    getNameSpecifier,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    LocationTrackNameSpecifier,
    LocationTrackNamingScheme,
    OperationalPoint,
    SplitPoint,
    splitPointsAreSame,
    SwitchNameParts,
    SwitchSplitPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicateTrack } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';
import { mapReducers } from 'map/map-store';
import { expectDefined } from 'utils/type-utils';
import { filterNotEmpty } from 'utils/array-utils';
import { inferLayoutContextMode } from 'linking/linking-store';
import { isEqualIgnoreCase } from 'utils/string-utils';

export const PARTIAL_DUPLICATE_MINIMUM_VALIDATED_DIFFERENCE_METERS = 0.05;
export const PARTIAL_DUPLICATE_EXPECTED_MINIMUM_NON_OVERLAPPING_PART_LENGTH_METERS = 10;

export type SplitTargetDuplicateOperation = 'TRANSFER' | 'OVERWRITE';
export type SplitTargetOperation = SplitTargetDuplicateOperation | 'CREATE';

export type SplitTargetId = number;

type SplitTargetCandidateBase = {
    id: SplitTargetId;
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: DuplicateStatus | undefined;
    location: Point;
    focusBehaviour: SplitFocusBehaviour;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation;
    splitPoint: SplitPoint;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
};

export type SplitTarget = FirstSplitTargetCandidate | SplitTargetCandidate;

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    duplicateTracks: SplitDuplicateTrack[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    focusedSplit: SplitTargetId | undefined;
    highlightedSplit: SplitTargetId | undefined;
    highlightedSplitPoint: SplitPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    prefilledSplitPoints: SplitPoint[];
    duplicateTracks: SplitDuplicateTrack[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    nameParts: SwitchNameParts;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperationalPoint: OperationalPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetDuplicateOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

type SplitFocusBehaviour = 'FOCUS' | 'NO_FOCUS';

let splitIdSequence = new Date().getTime();

function getNextSplitId(): number {
    return splitIdSequence++;
}

const findDuplicateStartingAt = (duplicates: SplitDuplicateTrack[], splitPoint: SplitPoint) => {
    return duplicates.find((duplicate) => {
        const duplicateSplitPoint = duplicate.status.startSplitPoint;
        return (
            duplicateSplitPoint !== undefined && splitPointsAreSame(splitPoint, duplicateSplitPoint)
        );
    });
};

export function getAllowedSwitchesFromState(state: SplittingState) {
    const startSwitchId =
        state.startSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.startSplitPoint.switchId;
    const endSwitchId =
        state.endSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.endSplitPoint.switchId;
    return state.trackSwitches.filter(
        (sw) => sw.switchId !== startSwitchId && sw.switchId !== endSwitchId,
    );
}

const prefillSplits = (
    prefilledSplitPoints: SplitPoint[],
    switchesOnTrack: SwitchOnLocationTrack[],
    duplicateTracks: SplitDuplicateTrack[],
    originTrackId: LocationTrackId,
): SplitTargetCandidate[] =>
    prefilledSplitPoints
        .map((splitPoint) => {
            const sw = findSwitchForSplitPoint(switchesOnTrack, splitPoint);
            return sw?.location !== undefined &&
                sw?.distance !== undefined &&
                sw?.address !== undefined &&
                splitPoint.type === 'SWITCH_SPLIT_POINT'
                ? ([
                      SwitchSplitPoint(
                          sw.switchId,
                          splitPoint.name,
                          { ...sw.location, m: 0 },
                          sw.address,
                      ),
                      sw.location,
                      sw.distance,
                  ] as const)
                : undefined;
        })
        .filter(filterNotEmpty)
        .map(([splitPoint, location, distance]) =>
            splitPointToSplitTargetCandidate(
                duplicateTracks,
                originTrackId,
                location,
                distance,
                splitPoint,
                'NO_FOCUS',
            ),
        )
        .sort((a, b) => a.distance - b.distance);

function getSwitch(switches: SwitchOnLocationTrack[], switchId: LayoutSwitchId) {
    return switches.find((sw) => sw.switchId === switchId);
}

function getStartSwitchId(state: SplittingState, split: SplitTarget) {
    return split.type === 'FIRST_SPLIT'
        ? state.startSplitPoint.type === 'SWITCH_SPLIT_POINT'
            ? state.startSplitPoint.switchId
            : undefined
        : split.splitPoint.type === 'SWITCH_SPLIT_POINT'
          ? split.splitPoint.switchId
          : undefined;
}

function getStartSwitch(state: SplittingState, split: SplitTarget) {
    const startSwitchId = getStartSwitchId(state, split);
    return startSwitchId && getSwitch(state.trackSwitches, startSwitchId);
}

function getEndSwitchId(state: SplittingState, split: SplitTarget) {
    const splitIndex = state.splits.findIndex((sp) => sp.id === split.id);
    const nextSplit = state.splits[splitIndex + 1];

    return nextSplit
        ? getStartSwitchId(state, nextSplit)
        : state.endSplitPoint.type === 'SWITCH_SPLIT_POINT'
          ? state.endSplitPoint.switchId
          : undefined;
}

function getEndSwitch(state: SplittingState, split: SplitTarget) {
    const endSwitchId = getEndSwitchId(state, split);
    return endSwitchId && getSwitch(state.trackSwitches, endSwitchId);
}

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const locationTrackSelected = state.selection.selectedItems.locationTracks.some(
            (lt) => lt === payload.locationTrack.id,
        );

        if (locationTrackSelected) {
            const startSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.startSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.startSplitPoint.switchId,
            );
            const endSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.endSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.endSplitPoint.switchId,
            );
            const duplicateAtStart = findDuplicateStartingAt(
                payload.duplicateTracks,
                payload.startSplitPoint,
            );
            const nameAndDesc =
                duplicateAtStart?.name === undefined
                    ? ({
                          ...getNameForTarget(
                              payload.trackNumber,
                              startSwitch,
                              endSwitch,
                              undefined,
                              getNameSpecifier(payload.locationTrack.nameStructure),
                          ),
                          hasAutogeneratedName: true,
                      } as const)
                    : ({
                          namingScheme: duplicateAtStart.nameStructure.scheme,
                          nameFreeText: getNameFreeText(duplicateAtStart?.nameStructure) ?? '',
                          nameSpecifier: getNameSpecifier(duplicateAtStart?.nameStructure),
                          name: duplicateAtStart.name,
                          descriptionBase: '',
                          hasAutogeneratedName: false,
                      } as const);
            const firstSplit: FirstSplitTargetCandidate = {
                id: getNextSplitId(),
                ...nameAndDesc,
                type: 'FIRST_SPLIT',
                duplicateTrackId: duplicateAtStart?.id,
                duplicateStatus: duplicateAtStart?.status,
                suffixMode: 'NONE',
                location: payload.startLocation,
                focusBehaviour: 'FOCUS',
                distance: 0,
                splitPoint: payload.startSplitPoint,
                operation: getOperation(payload.locationTrack.id, duplicateAtStart?.status),
            } as const;
            const prefilledSplits = prefillSplits(
                payload.prefilledSplitPoints,
                payload.trackSwitches,
                payload.duplicateTracks,
                payload.locationTrack.id,
            );

            const prefilledSplitsNamed = updateAutogeneratedSplitNames(
                payload.trackNumber,
                payload.startSplitPoint,
                payload.endSplitPoint,
                prefilledSplits,
                firstSplit,
                payload.trackSwitches,
                payload.duplicateTracks,
                getNameSpecifier(payload.locationTrack.nameStructure),
            );

            const newLayoutContext = draftLayoutContext(state.layoutContext);
            state.layoutContext = newLayoutContext;
            state.layoutContextMode = inferLayoutContextMode(newLayoutContext);

            state.splittingState = {
                state: 'SETUP',
                originLocationTrack: payload.locationTrack,
                trackSwitches: payload.trackSwitches,
                duplicateTracks: payload.duplicateTracks,
                endLocation: payload.endLocation,
                disabled: payload.locationTrack.isDraft,
                trackNumber: payload.trackNumber,
                focusedSplit: undefined,
                highlightedSplit: undefined,
                highlightedSplitPoint: undefined,
                startSplitPoint: payload.startSplitPoint,
                endSplitPoint: payload.endSplitPoint,
                ...prefilledSplitsNamed,
            };

            mapReducers.addForcedVisibleLayer(state.map, {
                payload: ['location-track-split-location-layer'],
                type: 'addForcedVisibleLayer',
            });
        }
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    unfocusSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.splits = state.splittingState.splits.map((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint)
                    ? { ...split, focusBehaviour: 'NO_FOCUS' }
                    : split,
            );
            if (state.splittingState.firstSplit.focusBehaviour === 'FOCUS') {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    focusBehaviour: 'NO_FOCUS',
                };
            }
        }
    },
    removeSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            const splitToRemove = state.splittingState.splits.find((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint),
            );
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => !splitPointsAreSame(split.splitPoint, splitPoint),
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
                focusedSplit:
                    splitToRemove?.id === state.splittingState.focusedSplit
                        ? undefined
                        : state.splittingState.focusedSplit,
                highlightedSplit:
                    splitToRemove?.id === state.splittingState.highlightedSplit
                        ? undefined
                        : state.splittingState.highlightedSplit,
                highlightedSplitPoint:
                    splitPoint === state.splittingState.highlightedSplitPoint
                        ? undefined
                        : state.splittingState.highlightedSplitPoint,
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            const startSwitch = getStartSwitch(state.splittingState, split);
            const endSwitch = getEndSwitch(state.splittingState, split);
            const fullName = formatTrackName(
                split.namingScheme,
                split.nameFreeText,
                split.nameSpecifier,
                state.splittingState.trackNumber,
                startSwitch?.nameParts,
                endSwitch?.nameParts,
            );

            const duplicate = state.splittingState.duplicateTracks.find((lt) =>
                isEqualIgnoreCase(lt.name, fullName),
            );
            const operation = getOperation(
                state.splittingState.originLocationTrack.id,
                duplicate?.status,
            );

            const refinedSplit = {
                ...split,
                name: fullName,
                duplicateTrackId: duplicate?.id,
                duplicateStatus: duplicate?.status,
                operation: operation,
            };

            if (refinedSplit.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter(
                        (splitToCheck) =>
                            !splitPointsAreSame(refinedSplit.splitPoint, splitToCheck.splitPoint),
                    )
                    .concat([refinedSplit])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = refinedSplit;
            }
        }
    },
    setHighlightedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplit = split;
        }
    },
    setFocusedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.focusedSplit = split;
        }
    },
    setHighlightedSplitPoint: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplitPoint = splitPoint;
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

const findSwitchForSplitPoint = (
    switchesOnLocationTrack: SwitchOnLocationTrack[],
    splitPoint: SplitPoint,
) =>
    switchesOnLocationTrack.find(
        (sw) => splitPoint.type === 'SWITCH_SPLIT_POINT' && sw.switchId === splitPoint.switchId,
    );

const isAlreadySplit = (existingSplits: SplitTargetCandidate[], splitPoint: SplitPoint) =>
    existingSplits.some((split) => splitPointsAreSame(splitPoint, split.splitPoint));

function splitPointToSplitTargetCandidate(
    duplicateTracks: SplitDuplicateTrack[],
    originLocationTrackId: LocationTrackId,
    switchLocation: Point,
    switchDistance: number,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour,
): SplitTargetCandidate {
    const duplicateAt = findDuplicateStartingAt(duplicateTracks, splitPoint);
    const name = duplicateAt?.name || '';

    return {
        id: getNextSplitId(),
        type: 'SPLIT',
        splitPoint: splitPoint,
        namingScheme:
            duplicateAt?.nameStructure?.scheme ??
            LocationTrackNamingScheme.BETWEEN_OPERATIONAL_POINTS,
        nameFreeText: getNameFreeText(duplicateAt?.nameStructure),
        nameSpecifier: getNameSpecifier(duplicateAt?.nameStructure),
        name,
        duplicateTrackId: duplicateAt?.id,
        duplicateStatus: duplicateAt?.status,
        descriptionBase: '',
        suffixMode: 'NONE',
        location: switchLocation,
        distance: switchDistance,
        focusBehaviour: splitFocusBehaviour,
        hasAutogeneratedName: name === '',
        operation: getOperation(originLocationTrackId, duplicateAt?.status),
    } as const;
}

export function addSplitToState(
    state: TrackLayoutState,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour = 'FOCUS',
) {
    if (state.splittingState) {
        const switchForSplitPoint = findSwitchForSplitPoint(
            state.splittingState.trackSwitches,
            splitPoint,
        );

        if (
            splitPoint.type === 'SWITCH_SPLIT_POINT' &&
            !isAlreadySplit(state.splittingState.splits, splitPoint) &&
            switchForSplitPoint?.distance !== undefined &&
            switchForSplitPoint?.location !== undefined
        ) {
            const newSplit = splitPointToSplitTargetCandidate(
                state.splittingState.duplicateTracks,
                state.splittingState.originLocationTrack.id,
                switchForSplitPoint.location,
                switchForSplitPoint.distance,
                splitPoint,
                splitFocusBehaviour,
            );

            const newState = {
                ...state.splittingState,
                splits: [...state.splittingState.splits, newSplit]
                    .filter(filterNotEmpty)
                    .sort((a, b) => a.distance - b.distance),
            } as const;

            state.splittingState = {
                ...newState,
                ...updateAutogeneratedSplitNamesFromState(newState),
            } as const;
        }
    }
}

function getLocationTrackDescription(
    prevStation: OperationalPoint,
    nextStation: OperationalPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    trackNumber: TrackNumber,
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
    duplicate: SplitDuplicateTrack | undefined,
    sourceNameSpecifier: LocationTrackNameSpecifier | undefined,
): {
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    name: string;
    descriptionBase: string;
} {
    const namingScheme: LocationTrackNamingScheme = duplicate
        ? duplicate.nameStructure.scheme
        : LocationTrackNamingScheme.BETWEEN_OPERATIONAL_POINTS;
    const nameSpecifier = duplicate?.nameStructure
        ? getNameSpecifier(duplicate.nameStructure)
        : sourceNameSpecifier;

    const nameFreeText =
        startSwitch?.nameParts !== undefined && endSwitch?.nameParts !== undefined
            ? `${startSwitch.nameParts.prefix} ${startSwitch.nameParts.shortNumberPart}-${endSwitch.nameParts.prefix} ${endSwitch.nameParts.shortNumberPart}`
            : '';

    return {
        namingScheme,
        nameFreeText,
        nameSpecifier,
        name: formatTrackName(
            namingScheme,
            nameFreeText,
            nameSpecifier,
            trackNumber,
            startSwitch?.nameParts,
            endSwitch?.nameParts,
        ),
        descriptionBase:
            startSwitch !== undefined &&
            startSwitch.nearestOperationalPoint !== undefined &&
            endSwitch !== undefined &&
            endSwitch.nearestOperationalPoint !== undefined &&
            startSwitch.nearestOperationalPoint.name !== endSwitch.nearestOperationalPoint.name
                ? getLocationTrackDescription(
                      startSwitch.nearestOperationalPoint,
                      endSwitch.nearestOperationalPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.trackNumber,
        splitState.startSplitPoint,
        splitState.endSplitPoint,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackSwitches,
        splitState.duplicateTracks,
        getNameSpecifier(splitState.originLocationTrack.nameStructure),
    );
}

function getDuplicateTrack(duplicates: SplitDuplicateTrack[], duplicateId: LocationTrackId) {
    return duplicates.find((duplicate) => duplicate.id === duplicateId);
}

function updateAutogeneratedSplitNames(
    trackNumber: TrackNumber,
    startSplitPoint: SplitPoint | undefined,
    endSplitPoint: SplitPoint | undefined,
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackSwitches: SwitchOnLocationTrack[],
    duplicates: SplitDuplicateTrack[],
    sourceTrackNameSpecifier: LocationTrackNameSpecifier | undefined,
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = trackSwitches.find(
        (sw) =>
            startSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === startSplitPoint.switchId,
    );
    const firstSplitEndSplitPoint =
        splits.length > 0 ? expectDefined(splits[0]).splitPoint : endSplitPoint;
    const firstSplitEndSwitch = trackSwitches.find(
        (sw) =>
            firstSplitEndSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === firstSplitEndSplitPoint.switchId,
    );
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(
                      trackNumber,
                      firstSwitch,
                      firstSplitEndSwitch,
                      firstSplit.duplicateTrackId &&
                          getDuplicateTrack(duplicates, firstSplit.duplicateTrackId),
                      sourceTrackNameSpecifier,
                  ),
              }
            : firstSplit;

    const endSwitch = trackSwitches.find(
        (sw) =>
            endSplitPoint?.type === 'SWITCH_SPLIT_POINT' && sw.switchId === endSplitPoint.switchId,
    );
    const newSplits = splits.map((split, index) => {
        const splitStartSwitch = trackSwitches.find(
            (sw) =>
                split.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                split.splitPoint.switchId === sw.switchId,
        );
        const nextSplit = index + 1 < splits.length ? splits[index + 1] : undefined;
        const splitEndSwitch = nextSplit
            ? trackSwitches.find(
                  (sw) =>
                      nextSplit.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                      nextSplit.splitPoint.switchId === sw.switchId,
              )
            : endSwitch;
        return split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(
                      trackNumber,
                      splitStartSwitch,
                      splitEndSwitch,
                      split.duplicateTrackId &&
                          getDuplicateTrack(duplicates, split.duplicateTrackId),
                      sourceTrackNameSpecifier,
                  ),
              }
            : split;
    });
    return { firstSplit: newFirstSplit, splits: newSplits };
}
