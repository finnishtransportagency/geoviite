import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate } from 'track-layout/layout-location-track-api';
import { getPlanarDistanceUnwrapped } from 'map/layers/utils/layer-utils';
import liikennepaikat from 'liikennepaikat.json';
import { pointInsidePolygon } from 'utils/math-utils';

const DUPLICATE_MAX_DISTANCE = 1.0;

type SplitTargetCandidateBase = {
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateOf?: LocationTrackId;
    location: Point;
    new: boolean;
    hasAutoGeneratedName?: boolean;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    switchId: LayoutSwitchId;
    distance: number;
};

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
};

type SplitStart = {
    locationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTarget = {
    duplicateTrackId: LocationTrackId | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

export const sortSplitsByDistance = (splits: SplitTargetCandidate[]) =>
    [...splits].sort((a, b) => a.distance - b.distance);

const findClosestDuplicate = (duplicates: SplitDuplicate[], otherPoint: Point) =>
    duplicates
        .map((dupe) => ({
            distance: getPlanarDistanceUnwrapped(
                dupe.start.point.x,
                dupe.start.point.y,
                otherPoint.x,
                otherPoint.y,
            ),
            duplicate: dupe,
        }))
        .sort((a, b) => a.distance - b.distance)[0];

type Station = {
    oid: string;
    name: string;
    abbr: string;
    coordinates: number[][][];
};

function findStation(point: Point, stations: Station[]): Station | undefined {
    return stations.find((station) => pointInsidePolygon(point, station.coordinates[0]));
}

function getLocationTrackName(
    trackNumber: TrackNumber,
    prevStation: Station,
    nextStation: Station,
): string {
    return `${trackNumber} ${prevStation.abbr}-${nextStation.abbr}`;
}

function getLocationTrackDescription(
    trackNumber: TrackNumber,
    prevStation: Station,
    nextStation: Station,
): string {
    return `Ratanumeron raide: ${trackNumber} ${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    from: Point,
    to: Point,
    stations: Station[],
    trackNumber: TrackNumber,
): { name: string; descriptionBase: string } {
    const fromStation = findStation(from, stations);
    const toStation = findStation(to, stations);
    return {
        name:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackName(trackNumber, fromStation, toStation)
                : '',
        descriptionBase:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackDescription(trackNumber, fromStation, toStation)
                : '',
    };
}

function getTargetsWithUpdatedNames(
    firstSplit: FirstSplitTargetCandidate,
    splits: SplitTargetCandidate[],
    endLocation: Point,
    stations: Station[],
    trackNumber: TrackNumber,
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const autoGeneratedNames = [firstSplit, ...splits].map((target, index, allTargets) => {
        const from = target.location;
        const to = index < allTargets.length - 1 ? allTargets[index + 1].location : endLocation;
        return {
            ...getNameForTarget(from, to, stations, trackNumber),
            hasAutoGeneratedName: true,
        };
    });

    const autogeneratedFirstSplitNames = autoGeneratedNames[0];
    const autoGeneratedSplitNames = autoGeneratedNames.slice(1);

    return {
        firstSplit: {
            ...firstSplit,
            ...(firstSplit.name == '' || firstSplit.hasAutoGeneratedName
                ? autogeneratedFirstSplitNames
                : {}),
        },
        splits: splits.map((split, index) => {
            return {
                ...split,
                ...(split.name == '' || split.hasAutoGeneratedName
                    ? autoGeneratedSplitNames[index]
                    : {}),
            };
        }),
    };
}

const stations = liikennepaikat.features.map((feature) => {
    const station: Station = {
        oid: feature.properties.tunniste,
        name: feature.properties.nimi,
        abbr: feature.properties.lyhenne.toUpperCase(),
        coordinates: feature.geometry.geometries[1].coordinates as unknown as number[][][],
    };
    return station;
});

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const duplicateTrackClosestToStart = findClosestDuplicate(
            payload.duplicateTracks,
            payload.startLocation,
        );
        state.publishType = 'DRAFT';
        const duplicateCloseToStart =
            duplicateTrackClosestToStart &&
            duplicateTrackClosestToStart.distance <= DUPLICATE_MAX_DISTANCE
                ? duplicateTrackClosestToStart
                : undefined;
        state.splittingState = {
            state: 'SETUP',
            originLocationTrack: payload.locationTrack,
            allowedSwitches: payload.allowedSwitches,
            startAndEndSwitches: payload.startAndEndSwitches,
            duplicateTracks: payload.duplicateTracks,
            splits: [],
            endLocation: payload.endLocation,
            disabled: payload.locationTrack.draftType !== 'OFFICIAL',
            firstSplit: {
                type: 'FIRST_SPLIT',
                name: duplicateCloseToStart?.duplicate.name || '',
                duplicateOf: duplicateCloseToStart?.duplicate.id,
                descriptionBase: '',
                suffixMode: 'NONE',
                location: payload.startLocation,
                new: true,
            },
            trackNumber: payload.trackNumber,
        };
        state.splittingState = {
            ...state.splittingState,
            ...getTargetsWithUpdatedNames(
                state.splittingState.firstSplit,
                state.splittingState.splits,
                state.splittingState.endLocation,
                stations,
                state.splittingState.trackNumber,
            ),
        };
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        const allowedSwitch = state.splittingState?.allowedSwitches?.find(
            (sw) => sw.switchId == payload,
        );
        if (
            state.splittingState &&
            !state.splittingState.disabled &&
            allowedSwitch?.location &&
            allowedSwitch?.distance &&
            !state.splittingState.splits.some((split) => split.switchId === payload)
        ) {
            const closestDupe = findClosestDuplicate(
                state.splittingState.duplicateTracks,
                allowedSwitch.location,
            );
            state.splittingState.splits = state.splittingState.splits.concat([
                {
                    type: 'SPLIT',
                    switchId: payload,
                    name:
                        closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                            ? closestDupe.duplicate.name
                            : '',
                    duplicateOf:
                        closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                            ? closestDupe.duplicate.id
                            : undefined,
                    descriptionBase: '',
                    suffixMode: 'NONE',
                    location: allowedSwitch.location,
                    distance: allowedSwitch.distance,
                    new: true,
                },
            ]);
            state.splittingState = {
                ...state.splittingState,
                ...getTargetsWithUpdatedNames(
                    state.splittingState.firstSplit,
                    state.splittingState.splits,
                    state.splittingState.endLocation,
                    stations,
                    state.splittingState.trackNumber,
                ),
            };
        }
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            if (payload) {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switchId === payload ? { ...split, new: false } : split,
                );
            } else {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        if (state.splittingState) {
            state.splittingState = {
                ...state.splittingState,
                ...getTargetsWithUpdatedNames(
                    state.splittingState.firstSplit,
                    state.splittingState.splits.filter((split) => split.switchId !== payload),
                    state.splittingState.endLocation,
                    stations,
                    state.splittingState.trackNumber,
                ),
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (payload.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter((split) => split.switchId !== payload.switchId)
                    .concat([
                        {
                            ...payload,
                            hasAutoGeneratedName: false,
                        },
                    ]);
            } else {
                state.splittingState.firstSplit = {
                    ...payload,
                    hasAutoGeneratedName: false,
                };
            }
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};
