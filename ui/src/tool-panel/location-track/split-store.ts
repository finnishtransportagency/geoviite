import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate } from 'track-layout/layout-location-track-api';
import { getPlanarDistanceUnwrapped } from 'map/layers/utils/layer-utils';
import { findInsertionIndex, insertAtIndex } from 'utils/array-utils';

const DUPLICATE_MAX_DISTANCE = 1.0;

type SplitTargetCandidateBase = {
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateOf?: LocationTrackId;
    location: Point;
    new: boolean;
    hasAutogeneratedName: boolean;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    switch: SwitchOnLocationTrack;
    distance: number;
};

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTarget = {
    duplicateTrackId: LocationTrackId | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

const findClosestDuplicate = (duplicates: SplitDuplicate[], otherPoint: Point) =>
    duplicates
        .map((dupe) => ({
            distance: getPlanarDistanceUnwrapped(
                dupe.start.point.x,
                dupe.start.point.y,
                otherPoint.x,
                otherPoint.y,
            ),
            duplicate: dupe,
        }))
        .sort((a, b) => a.distance - b.distance)[0];

function getSwitchById(
    swithces: SwitchOnLocationTrack[],
    switchId: LayoutSwitchId,
): SwitchOnLocationTrack | undefined {
    return swithces.find((switchToCheck) => switchToCheck.switchId === switchId);
}

function getAllowedSwitches(
    trackSwitches: SwitchOnLocationTrack[],
    startAndEndSwitches: LayoutSwitchId[],
): SwitchOnLocationTrack[] {
    return trackSwitches.filter(
        (sw) => sw.switchId != startAndEndSwitches[0] && sw.switchId != startAndEndSwitches[1],
    );
}

export function getAllowedSwitchesFromState(state: SplittingState) {
    return getAllowedSwitches(state.trackSwitches, state.startAndEndSwitches);
}

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const startSwitch = getSwitchById(payload.trackSwitches, payload.startAndEndSwitches[0]);
        const endSwitch = getSwitchById(payload.trackSwitches, payload.startAndEndSwitches[1]);

        const duplicateTrackClosestToStart = findClosestDuplicate(
            payload.duplicateTracks,
            payload.startLocation,
        );
        const firstSplitBase = {
            type: 'FIRST_SPLIT',
            name:
                duplicateTrackClosestToStart &&
                duplicateTrackClosestToStart.distance <= DUPLICATE_MAX_DISTANCE
                    ? duplicateTrackClosestToStart.duplicate.name
                    : '',
            duplicateOf:
                duplicateTrackClosestToStart &&
                duplicateTrackClosestToStart.distance <= DUPLICATE_MAX_DISTANCE
                    ? duplicateTrackClosestToStart.duplicate.id
                    : undefined,
            descriptionBase: '',
            suffixMode: 'NONE',
            location: payload.startLocation,
            new: true,
        } as const;
        const firstSplit =
            firstSplitBase.name === ''
                ? ({
                      ...firstSplitBase,
                      ...getNameForTarget(startSwitch, endSwitch, payload.trackNumber),
                      hasAutogeneratedName: true,
                  } as const)
                : ({ ...firstSplitBase, hasAutogeneratedName: false } as const);
        state.layoutContext = draftLayoutContext(state.layoutContext);
        state.splittingState = {
            state: 'SETUP',
            originLocationTrack: payload.locationTrack,
            trackSwitches: payload.trackSwitches,
            startAndEndSwitches: payload.startAndEndSwitches,
            duplicateTracks: payload.duplicateTracks,
            splits: [],
            endLocation: payload.endLocation,
            disabled: payload.locationTrack.editState !== 'UNEDITED',
            firstSplit,
            trackNumber: payload.trackNumber,
        };
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        const allowedSwitches =
            state.splittingState !== undefined
                ? getAllowedSwitchesFromState(state.splittingState)
                : [];
        const allowedSwitchIndex = allowedSwitches.findIndex((sw) => sw.switchId == payload);
        const allowedSwitch =
            allowedSwitchIndex === undefined ? undefined : allowedSwitches[allowedSwitchIndex];
        const allowedSwitchDistance = allowedSwitch?.distance;
        if (
            state.splittingState &&
            !state.splittingState.disabled &&
            allowedSwitch?.location &&
            allowedSwitchDistance !== undefined &&
            !state.splittingState.splits.some((split) => split.switch.switchId === payload)
        ) {
            const closestDupe = findClosestDuplicate(
                state.splittingState.duplicateTracks,
                allowedSwitch.location,
            );
            const newSplitIndex = findInsertionIndex(
                state.splittingState.splits,
                (split) => split.distance > allowedSwitchDistance,
            );
            const name =
                closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                    ? closestDupe.duplicate.name
                    : '';
            const newSplit = {
                type: 'SPLIT',
                switch: allowedSwitch,
                name,
                duplicateOf:
                    closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                        ? closestDupe.duplicate.id
                        : undefined,
                descriptionBase: '',
                suffixMode: 'NONE',
                location: allowedSwitch.location,
                distance: allowedSwitchDistance,
                new: true,
                hasAutogeneratedName: name === '',
            } as const;

            const newState = {
                ...state.splittingState,
                splits: insertAtIndex(state.splittingState.splits, newSplit, newSplitIndex),
            } as const;

            state.splittingState = {
                ...newState,
                ...updateAutogeneratedSplitNamesFromState(newState),
            } as const;
        }
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            if (payload) {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switch.switchId === payload ? { ...split, new: false } : split,
                );
            } else {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        if (state.splittingState) {
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => split.switch.switchId !== payload,
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (payload.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter((split) => split.switch.switchId !== payload.switch.switchId)
                    .concat([payload]);
            } else {
                state.splittingState.firstSplit = payload;
            }
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function getTrackNameFormattedSwitchName(switchName: string): string {
    return switchName.replace(/\s+/g, ' ').replace(/V0(\d{3})/, 'V$1');
}

function getLocationTrackName(startSwitchName: string, endSwitchName: string): string {
    return `${getTrackNameFormattedSwitchName(startSwitchName)}-${getTrackNameFormattedSwitchName(endSwitchName)}`;
}

function getLocationTrackDescription(
    _trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
    trackNumber: TrackNumber,
): { name: string; descriptionBase: string } {
    return {
        name:
            startSwitch !== undefined && endSwitch !== undefined
                ? getLocationTrackName(startSwitch.name, endSwitch.name)
                : '',
        descriptionBase:
            startSwitch != undefined &&
            startSwitch.nearestOperatingPoint != undefined &&
            endSwitch != undefined &&
            endSwitch.nearestOperatingPoint != undefined &&
            startSwitch.nearestOperatingPoint.name != endSwitch.nearestOperatingPoint.name
                ? getLocationTrackDescription(
                      trackNumber,
                      startSwitch.nearestOperatingPoint,
                      endSwitch.nearestOperatingPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.startAndEndSwitches,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackNumber,
        splitState.trackSwitches,
    );
}

function updateAutogeneratedSplitNames(
    startAndEndSwitches: LayoutSwitchId[],
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackNumber: TrackNumber,
    trackSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = getSwitchById(trackSwitches, startAndEndSwitches[0]);
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(firstSwitch, splits[0].switch, trackNumber),
              }
            : firstSplit;

    const endSwitch = getSwitchById(trackSwitches, startAndEndSwitches[1]);
    const newSplits = splits.map((split, index) =>
        split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(
                      split.switch,
                      index + 1 < splits.length ? splits[index + 1].switch : endSwitch,
                      trackNumber,
                  ),
              }
            : split,
    );
    return { firstSplit: newFirstSplit, splits: newSplits };
}
