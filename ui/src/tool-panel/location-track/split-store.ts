import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    DuplicateStatus,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';
import { mapReducers } from 'map/map-store';

export type SplitTargetDuplicateOperation = 'TRANSFER' | 'OVERWRITE';
export type SplitTargetOperation = SplitTargetDuplicateOperation | 'CREATE';

export type SplitTargetId = number;

type SplitTargetCandidateBase = {
    id: SplitTargetId;
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: DuplicateStatus | undefined;
    location: Point;
    new: boolean;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation;
    switch: SwitchOnLocationTrack | undefined;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
    switch: SwitchOnLocationTrack;
};

export type SplitTarget = FirstSplitTargetCandidate | SplitTargetCandidate;

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSwitchId: LayoutSwitchId | undefined;
    endSwitchId: LayoutSwitchId | undefined;
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    focusedSplit: SplitTargetId | undefined;
    highlightedSplit: SplitTargetId | undefined;
    highlightedSwitch: LayoutSwitchId | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSwitchId: LayoutSwitchId | undefined;
    endSwitchId: LayoutSwitchId | undefined;
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetDuplicateOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

let splitIdSequence = new Date().getTime();

function getNextSplitId(): number {
    return splitIdSequence++;
}

const findDuplicateStartingAt = (
    duplicates: SplitDuplicate[],
    switchId: LayoutSwitchId | undefined,
) => {
    return duplicates.find((duplicate) => {
        return duplicate.status.startSwitchId === switchId;
    });
};

export function getAllowedSwitchesFromState(state: SplittingState) {
    return state.trackSwitches.filter(
        (sw) => sw.switchId != state.startSwitchId && sw.switchId != state.endSwitchId,
    );
}

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const locationTrackSelected = state.selection.selectedItems.locationTracks.some(
            (lt) => lt === payload.locationTrack.id,
        );

        if (locationTrackSelected) {
            const startSwitch = payload.trackSwitches.find(
                (sw) => sw.switchId == payload.startSwitchId,
            );
            const endSwitch = payload.trackSwitches.find(
                (sw) => sw.switchId == payload.endSwitchId,
            );
            const duplicateAtStart = findDuplicateStartingAt(
                payload.duplicateTracks,
                payload.startSwitchId,
            );
            const nameAndDesc =
                duplicateAtStart?.name === undefined
                    ? ({
                          ...getNameForTarget(startSwitch, endSwitch, payload.trackNumber),
                          hasAutogeneratedName: true,
                      } as const)
                    : ({
                          name: duplicateAtStart.name,
                          descriptionBase: '',
                          hasAutogeneratedName: false,
                      } as const);
            const firstSplit: FirstSplitTargetCandidate = {
                id: getNextSplitId(),
                ...nameAndDesc,
                type: 'FIRST_SPLIT',
                duplicateTrackId: duplicateAtStart?.id,
                duplicateStatus: duplicateAtStart?.status,
                suffixMode: 'NONE',
                location: payload.startLocation,
                new: true,
                distance: 0,
                switch: startSwitch,
                operation: getOperation(
                    payload.locationTrack.id,
                    payload.startSwitchId,
                    duplicateAtStart?.status,
                ),
            } as const;
            state.layoutContext = draftLayoutContext(state.layoutContext);
            state.splittingState = {
                state: 'SETUP',
                originLocationTrack: payload.locationTrack,
                trackSwitches: payload.trackSwitches,
                startSwitchId: payload.startSwitchId,
                endSwitchId: payload.endSwitchId,
                duplicateTracks: payload.duplicateTracks,
                splits: [],
                endLocation: payload.endLocation,
                disabled: payload.locationTrack.editState !== 'UNEDITED',
                firstSplit,
                trackNumber: payload.trackNumber,
                focusedSplit: undefined,
                highlightedSplit: undefined,
                highlightedSwitch: undefined,
            };

            mapReducers.showLayers(state.map, {
                payload: ['location-track-split-location-layer'],
                type: 'showLayers',
            });
        }
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        addSplitToState(state, payload);
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload: switchId }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            if (switchId) {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switch?.switchId === switchId ? { ...split, new: false } : split,
                );
            } else {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (
        state: TrackLayoutState,
        { payload: switchId }: PayloadAction<LayoutSwitchId>,
    ): void => {
        if (state.splittingState) {
            const splitToRemove = state.splittingState.splits.find(
                (split) => split.switch?.switchId == switchId,
            );
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => split.switch?.switchId !== switchId,
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
                focusedSplit:
                    splitToRemove?.id == state.splittingState.focusedSplit
                        ? undefined
                        : state.splittingState.focusedSplit,
                highlightedSplit:
                    splitToRemove?.id == state.splittingState.highlightedSplit
                        ? undefined
                        : state.splittingState.highlightedSplit,
                highlightedSwitch:
                    switchId == state.splittingState.highlightedSwitch
                        ? undefined
                        : state.splittingState.highlightedSwitch,
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (split.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter(
                        (splitToCheck) => splitToCheck.switch?.switchId !== split.switch?.switchId,
                    )
                    .concat([split])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = split;
            }
        }
    },
    setHighlightedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplit = split;
        }
    },
    setFocusedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.focusedSplit = split;
        }
    },
    setHighlightedSwitch: (
        state: TrackLayoutState,
        { payload: switchId }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSwitch = switchId;
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function getTrackNameFormattedSwitchName(switchName: string): string {
    return switchName.replace(/\s+/g, ' ').replace(/V0(\d{3})/, 'V$1');
}

function getLocationTrackName(startSwitchName: string, endSwitchName: string): string {
    return `${getTrackNameFormattedSwitchName(startSwitchName)}-${getTrackNameFormattedSwitchName(endSwitchName)}`;
}

function addSplitToState(state: TrackLayoutState, switchId: LayoutSwitchId) {
    const allowedSwitches =
        state.splittingState !== undefined ? getAllowedSwitchesFromState(state.splittingState) : [];
    const allowedSwitchIndex = allowedSwitches?.findIndex((sw) => sw.switchId == switchId);
    const isAlreadySplit = state.splittingState?.splits.some(
        (s) => s.switch?.switchId === switchId,
    );
    const allowedSwitch =
        allowedSwitchIndex === undefined ? undefined : allowedSwitches[allowedSwitchIndex];
    const allowedSwitchDistance = allowedSwitch?.distance;
    if (
        !isAlreadySplit &&
        state.splittingState &&
        !state.splittingState.disabled &&
        allowedSwitch?.location &&
        allowedSwitchDistance !== undefined
    ) {
        const duplicateAt = findDuplicateStartingAt(state.splittingState.duplicateTracks, switchId);
        const name = duplicateAt?.name || '';
        const newSplit: SplitTargetCandidate = {
            id: getNextSplitId(),
            type: 'SPLIT',
            switch: allowedSwitch,
            name,
            duplicateTrackId: duplicateAt?.id,
            duplicateStatus: duplicateAt?.status,
            descriptionBase: '',
            suffixMode: 'NONE',
            location: allowedSwitch.location,
            distance: allowedSwitchDistance,
            new: true,
            hasAutogeneratedName: name === '',
            operation: getOperation(
                state.splittingState.originLocationTrack.id,
                switchId,
                duplicateAt?.status,
            ),
        } as const;

        const newState = {
            ...state.splittingState,
            splits: state.splittingState.splits
                .concat([newSplit])
                .sort((a, b) => a.distance - b.distance),
        } as const;

        state.splittingState = {
            ...newState,
            ...updateAutogeneratedSplitNamesFromState(newState),
        } as const;

        // TODO: GVT-2552 this adds the end switch and recursively onwards.
        // Instead, a similar trick can be done from a separate user-action for all duplicates
        // if (duplicateAt && duplicateAt.status.endSwitchId !== undefined) {
        //     addSplitToState(state, duplicateAt.status.endSwitchId);
        // }
    }
}

function getLocationTrackDescription(
    _trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
    trackNumber: TrackNumber,
): {
    name: string;
    descriptionBase: string;
} {
    return {
        name:
            startSwitch !== undefined && endSwitch !== undefined
                ? getLocationTrackName(startSwitch.name, endSwitch.name)
                : '',
        descriptionBase:
            startSwitch != undefined &&
            startSwitch.nearestOperatingPoint != undefined &&
            endSwitch != undefined &&
            endSwitch.nearestOperatingPoint != undefined &&
            startSwitch.nearestOperatingPoint.name != endSwitch.nearestOperatingPoint.name
                ? getLocationTrackDescription(
                      trackNumber,
                      startSwitch.nearestOperatingPoint,
                      endSwitch.nearestOperatingPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.startSwitchId,
        splitState.endSwitchId,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackNumber,
        splitState.trackSwitches,
    );
}

function updateAutogeneratedSplitNames(
    startSwitchId: LayoutSwitchId | undefined,
    endSwitchId: LayoutSwitchId | undefined,
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackNumber: TrackNumber,
    trackSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = trackSwitches.find((sw) => sw.switchId == startSwitchId);
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(firstSwitch, splits[0].switch, trackNumber),
              }
            : firstSplit;

    const endSwitch = trackSwitches.find((sw) => sw.switchId == endSwitchId);
    const newSplits = splits.map((split, index) =>
        split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(
                      split.switch,
                      index + 1 < splits.length ? splits[index + 1].switch : endSwitch,
                      trackNumber,
                  ),
              }
            : split,
    );
    return { firstSplit: newFirstSplit, splits: newSplits };
}
