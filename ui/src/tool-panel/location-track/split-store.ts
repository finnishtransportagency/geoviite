import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    DuplicateStatus,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
    SplitPoint,
    splitPointsAreSame,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';
import { mapReducers } from 'map/map-store';
import { expectDefined } from 'utils/type-utils';
import { filterNotEmpty } from 'utils/array-utils';

export type SplitTargetDuplicateOperation = 'TRANSFER' | 'OVERWRITE';
export type SplitTargetOperation = SplitTargetDuplicateOperation | 'CREATE';

export type SplitTargetId = number;

type SplitTargetCandidateBase = {
    id: SplitTargetId;
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: DuplicateStatus | undefined;
    location: Point;
    new: boolean;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation;
    splitPoint: SplitPoint;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
};

export type SplitTarget = FirstSplitTargetCandidate | SplitTargetCandidate;

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    focusedSplit: SplitTargetId | undefined;
    highlightedSplit: SplitTargetId | undefined;
    highlightedSplitPoint: SplitPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    prefilledSplitPoints: SplitPoint[];
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetDuplicateOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

let splitIdSequence = new Date().getTime();

function getNextSplitId(): number {
    return splitIdSequence++;
}

const findDuplicateStartingAt = (duplicates: SplitDuplicate[], splitPoint: SplitPoint) => {
    return duplicates.find((duplicate) => {
        const duplicateSplitPoint = duplicate.status.startSplitPoint;
        return (
            duplicateSplitPoint != undefined && splitPointsAreSame(splitPoint, duplicateSplitPoint)
        );
    });
};

const _findDuplicateStartingAtSwitch = (duplicates: SplitDuplicate[], splitPoint: SplitPoint) => {
    return duplicates.find((duplicate) => {
        const duplicateSplitPoint = duplicate.status.startSplitPoint;
        if (duplicateSplitPoint === undefined) {
            return false;
        }
        switch (splitPoint.type) {
            case 'SWITCH_SPLIT_POINT':
                return (
                    duplicateSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    duplicateSplitPoint.switchId === splitPoint.switchId
                );
            case 'ENDPOINT_SPLIT_POINT':
                return (
                    duplicateSplitPoint.type === 'ENDPOINT_SPLIT_POINT' &&
                    duplicateSplitPoint.endpointType === splitPoint.endpointType
                );
        }
    });
};

export function getAllowedSwitchesFromState(state: SplittingState) {
    const startSwitchId =
        state.startSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.startSplitPoint.switchId;
    const endSwitchId =
        state.endSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.endSplitPoint.switchId;
    return state.trackSwitches.filter(
        (sw) => sw.switchId != startSwitchId && sw.switchId != endSwitchId,
    );
}

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const locationTrackSelected = state.selection.selectedItems.locationTracks.some(
            (lt) => lt === payload.locationTrack.id,
        );

        if (locationTrackSelected) {
            const startSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.startSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.startSplitPoint.switchId,
            );
            const endSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.endSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.endSplitPoint.switchId,
            );
            const duplicateAtStart = findDuplicateStartingAt(
                payload.duplicateTracks,
                payload.startSplitPoint,
            );
            const nameAndDesc =
                duplicateAtStart?.name === undefined
                    ? ({
                          ...getNameForTarget(startSwitch, endSwitch, payload.trackNumber),
                          hasAutogeneratedName: true,
                      } as const)
                    : ({
                          name: duplicateAtStart.name,
                          descriptionBase: '',
                          hasAutogeneratedName: false,
                      } as const);
            const firstSplit: FirstSplitTargetCandidate = {
                id: getNextSplitId(),
                ...nameAndDesc,
                type: 'FIRST_SPLIT',
                duplicateTrackId: duplicateAtStart?.id,
                duplicateStatus: duplicateAtStart?.status,
                suffixMode: 'NONE',
                location: payload.startLocation,
                new: true,
                distance: 0,
                splitPoint: payload.startSplitPoint,
                operation: getOperation(payload.locationTrack.id, duplicateAtStart?.status),
            } as const;

            const prefilledSplits = payload.prefilledSplitPoints
                .map((splitPoint) =>
                    splitPointToSplitTargetCandidate(
                        payload.trackSwitches,
                        [],
                        payload.duplicateTracks,
                        payload.locationTrack.id,
                        false,
                        splitPoint,
                    ),
                )
                .filter(filterNotEmpty)
                .sort((a, b) => a.distance - b.distance) as SplitTargetCandidate[];

            state.layoutContext = draftLayoutContext(state.layoutContext);
            state.splittingState = {
                state: 'SETUP',
                originLocationTrack: payload.locationTrack,
                trackSwitches: payload.trackSwitches,
                duplicateTracks: payload.duplicateTracks,
                splits: prefilledSplits,
                endLocation: payload.endLocation,
                disabled: payload.locationTrack.editState !== 'UNEDITED',
                firstSplit,
                trackNumber: payload.trackNumber,
                focusedSplit: undefined,
                highlightedSplit: undefined,
                highlightedSplitPoint: undefined,
                startSplitPoint: payload.startSplitPoint,
                endSplitPoint: payload.endSplitPoint,
            };

            mapReducers.showLayers(state.map, {
                payload: ['location-track-split-location-layer'],
                type: 'showLayers',
            });
        }
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        addSplitToState(state, splitPoint, true);
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.splits = state.splittingState.splits.map((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint) ? { ...split, new: false } : split,
            );
            if (state.splittingState.firstSplit.new) {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            const splitToRemove = state.splittingState.splits.find((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint),
            );
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => !splitPointsAreSame(split.splitPoint, splitPoint),
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
                focusedSplit:
                    splitToRemove?.id === state.splittingState.focusedSplit
                        ? undefined
                        : state.splittingState.focusedSplit,
                highlightedSplit:
                    splitToRemove?.id === state.splittingState.highlightedSplit
                        ? undefined
                        : state.splittingState.highlightedSplit,
                highlightedSplitPoint:
                    splitPoint == state.splittingState.highlightedSplitPoint
                        ? undefined
                        : state.splittingState.highlightedSplitPoint,
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (split.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter(
                        (splitToCheck) =>
                            !splitPointsAreSame(split.splitPoint, splitToCheck.splitPoint),
                    )
                    .concat([split])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = split;
            }
        }
    },
    setHighlightedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplit = split;
        }
    },
    setFocusedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.focusedSplit = split;
        }
    },
    setHighlightedSplitPoint: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplitPoint = splitPoint;
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function getTrackNameFormattedSwitchName(switchName: string): string {
    // Example:
    // V0123 -> V123
    // <space><space><space>V0123<space><space> -> <space>V123<space>
    return switchName.replace(/\s+/g, ' ').replace(/V0(\d{3})/, 'V$1');
}

function getLocationTrackName(startSwitchName: string, endSwitchName: string): string {
    return `${getTrackNameFormattedSwitchName(startSwitchName)}-${getTrackNameFormattedSwitchName(
        endSwitchName,
    )}`;
}

function splitPointToSplitTargetCandidate(
    allowedSwitches: SwitchOnLocationTrack[],
    existingSplits: SplitTargetCandidate[],
    duplicateTracks: SplitDuplicate[],
    originLocationTrackId: LocationTrackId,
    focusNameAfterCreate: boolean,
    splitPoint: SplitPoint,
): SplitTargetCandidate | undefined {
    // Currently allows switch split points only
    const allowedSwitchIndex = allowedSwitches?.findIndex(
        (sw) => splitPoint.type === 'SWITCH_SPLIT_POINT' && sw.switchId === splitPoint.switchId,
    );
    const isAlreadySplit = existingSplits.some((split) =>
        splitPointsAreSame(splitPoint, split.splitPoint),
    );
    const allowedSwitch =
        allowedSwitchIndex === undefined ? undefined : allowedSwitches[allowedSwitchIndex];
    const allowedSwitchDistance = allowedSwitch?.distance;
    if (!isAlreadySplit && allowedSwitch?.location && allowedSwitchDistance !== undefined) {
        const duplicateAt = findDuplicateStartingAt(duplicateTracks, splitPoint);
        const name = duplicateAt?.name || '';
        return {
            id: getNextSplitId(),
            type: 'SPLIT',
            splitPoint: splitPoint,
            name,
            duplicateTrackId: duplicateAt?.id,
            duplicateStatus: duplicateAt?.status,
            descriptionBase: '',
            suffixMode: 'NONE',
            location: allowedSwitch.location,
            distance: allowedSwitchDistance,
            new: focusNameAfterCreate,
            hasAutogeneratedName: name === '',
            operation: getOperation(originLocationTrackId, duplicateAt?.status),
        } as const;
    }
}

function addSplitToState(
    state: TrackLayoutState,
    splitPoint: SplitPoint,
    focusNameAfterCreate: boolean,
) {
    if (state.splittingState) {
        const newSplit = splitPointToSplitTargetCandidate(
            getAllowedSwitchesFromState(state.splittingState),
            state.splittingState.splits,
            state.splittingState.duplicateTracks,
            state.splittingState.originLocationTrack.id,
            focusNameAfterCreate,
            splitPoint,
        );

        const newState = {
            ...state.splittingState,
            splits: [...state.splittingState.splits, newSplit]
                .filter(filterNotEmpty)
                .sort((a, b) => a.distance - b.distance),
        } as const;

        state.splittingState = {
            ...newState,
            ...updateAutogeneratedSplitNamesFromState(newState),
        } as const;
    }
}

function getLocationTrackDescription(
    _trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
    trackNumber: TrackNumber,
): {
    name: string;
    descriptionBase: string;
} {
    return {
        name:
            startSwitch !== undefined && endSwitch !== undefined
                ? getLocationTrackName(startSwitch.name, endSwitch.name)
                : '',
        descriptionBase:
            startSwitch != undefined &&
            startSwitch.nearestOperatingPoint != undefined &&
            endSwitch != undefined &&
            endSwitch.nearestOperatingPoint != undefined &&
            startSwitch.nearestOperatingPoint.name != endSwitch.nearestOperatingPoint.name
                ? getLocationTrackDescription(
                      trackNumber,
                      startSwitch.nearestOperatingPoint,
                      endSwitch.nearestOperatingPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.startSplitPoint,
        splitState.endSplitPoint,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackNumber,
        splitState.trackSwitches,
    );
}

function updateAutogeneratedSplitNames(
    startSplitPoint: SplitPoint | undefined,
    endSplitPoint: SplitPoint | undefined,
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackNumber: TrackNumber,
    trackSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = trackSwitches.find(
        (sw) =>
            startSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === startSplitPoint.switchId,
    );
    const firstSplitEndSplitPoint =
        splits.length > 0 ? expectDefined(splits[0]).splitPoint : endSplitPoint;
    const firstSplitEndSwitch = trackSwitches.find(
        (sw) =>
            firstSplitEndSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === firstSplitEndSplitPoint.switchId,
    );
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(firstSwitch, firstSplitEndSwitch, trackNumber),
              }
            : firstSplit;

    const endSwitch = trackSwitches.find(
        (sw) =>
            endSplitPoint?.type === 'SWITCH_SPLIT_POINT' && sw.switchId === endSplitPoint.switchId,
    );
    const newSplits = splits.map((split, index) => {
        const splitStartSwitch = trackSwitches.find(
            (sw) =>
                split.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                split.splitPoint.switchId === sw.switchId,
        );
        const nextSplit = index + 1 < splits.length ? splits[index + 1] : undefined;
        const splitEndSwitch = nextSplit
            ? trackSwitches.find(
                  (sw) =>
                      nextSplit.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                      nextSplit.splitPoint.switchId === sw.switchId,
              )
            : endSwitch;
        return split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(splitStartSwitch, splitEndSwitch, trackNumber),
              }
            : split;
    });
    return { firstSplit: newFirstSplit, splits: newSplits };
}
