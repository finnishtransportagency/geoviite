import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate } from 'track-layout/layout-location-track-api';
import { getPlanarDistanceUnwrapped } from 'map/layers/utils/layer-utils';
import { findInsertionIndex, insertAtIndex } from 'utils/array-utils';

const DUPLICATE_MAX_DISTANCE = 1.0;

type SplitTargetCandidateBase = {
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateOf?: LocationTrackId;
    location: Point;
    new: boolean;
    hasAutogeneratedName: boolean;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    switchId: LayoutSwitchId;
    distance: number;
};

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    nearestOperatingPointToStart: OperatingPoint | undefined;
    nearestOperatingPointToEnd: OperatingPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
    nearestOperatingPointToStart: OperatingPoint | undefined;
    nearestOperatingPointToEnd: OperatingPoint | undefined;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTarget = {
    duplicateTrackId: LocationTrackId | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

const findClosestDuplicate = (duplicates: SplitDuplicate[], otherPoint: Point) =>
    duplicates
        .map((dupe) => ({
            distance: getPlanarDistanceUnwrapped(
                dupe.start.point.x,
                dupe.start.point.y,
                otherPoint.x,
                otherPoint.y,
            ),
            duplicate: dupe,
        }))
        .sort((a, b) => a.distance - b.distance)[0];

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const duplicateTrackClosestToStart = findClosestDuplicate(
            payload.duplicateTracks,
            payload.startLocation,
        );
        const firstSplitBase = {
            type: 'FIRST_SPLIT',
            name:
                duplicateTrackClosestToStart &&
                duplicateTrackClosestToStart.distance <= DUPLICATE_MAX_DISTANCE
                    ? duplicateTrackClosestToStart.duplicate.name
                    : '',
            duplicateOf:
                duplicateTrackClosestToStart &&
                duplicateTrackClosestToStart.distance <= DUPLICATE_MAX_DISTANCE
                    ? duplicateTrackClosestToStart.duplicate.id
                    : undefined,
            descriptionBase: '',
            suffixMode: 'NONE',
            location: payload.startLocation,
            new: true,
        } as const;
        const firstSplit =
            firstSplitBase.name === ''
                ? ({
                      ...firstSplitBase,
                      ...getNameForTarget(
                          payload.nearestOperatingPointToStart,
                          payload.nearestOperatingPointToEnd,
                          payload.trackNumber,
                      ),
                      hasAutogeneratedName: true,
                  } as const)
                : ({ ...firstSplitBase, hasAutogeneratedName: false } as const);
        state.layoutContext = draftLayoutContext(state.layoutContext);
        state.splittingState = {
            state: 'SETUP',
            originLocationTrack: payload.locationTrack,
            allowedSwitches: payload.allowedSwitches,
            startAndEndSwitches: payload.startAndEndSwitches,
            duplicateTracks: payload.duplicateTracks,
            splits: [],
            endLocation: payload.endLocation,
            disabled: payload.locationTrack.editState !== 'UNEDITED',
            firstSplit,
            trackNumber: payload.trackNumber,
            nearestOperatingPointToStart: payload.nearestOperatingPointToStart,
            nearestOperatingPointToEnd: payload.nearestOperatingPointToEnd,
        };
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        const allowedSwitchIndex = state.splittingState?.allowedSwitches?.findIndex(
            (sw) => sw.switchId == payload,
        );
        const allowedSwitch =
            allowedSwitchIndex === undefined
                ? undefined
                : state.splittingState?.allowedSwitches?.[allowedSwitchIndex];
        const allowedSwitchDistance = allowedSwitch?.distance;
        if (
            state.splittingState &&
            !state.splittingState.disabled &&
            allowedSwitch?.location &&
            allowedSwitchDistance !== undefined &&
            !state.splittingState.splits.some((split) => split.switchId === payload)
        ) {
            const closestDupe = findClosestDuplicate(
                state.splittingState.duplicateTracks,
                allowedSwitch.location,
            );
            const newSplitIndex = findInsertionIndex(
                state.splittingState.splits,
                (split) => split.distance > allowedSwitchDistance,
            );
            const name =
                closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                    ? closestDupe.duplicate.name
                    : '';
            const newSplit = {
                type: 'SPLIT',
                switchId: payload,
                name,
                duplicateOf:
                    closestDupe && closestDupe.distance <= DUPLICATE_MAX_DISTANCE
                        ? closestDupe.duplicate.id
                        : undefined,
                descriptionBase: '',
                suffixMode: 'NONE',
                location: allowedSwitch.location,
                distance: allowedSwitchDistance,
                new: true,
                hasAutogeneratedName: name === '',
            } as const;

            const newState = {
                ...state.splittingState,
                splits: insertAtIndex(state.splittingState.splits, newSplit, newSplitIndex),
            } as const;

            state.splittingState = {
                ...newState,
                ...updateAutogeneratedSplitNamesFromState(newState),
            } as const;
        }
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            if (payload) {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switchId === payload ? { ...split, new: false } : split,
                );
            } else {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        if (state.splittingState) {
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter((split) => split.switchId !== payload),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (payload.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switchId === payload.switchId ? payload : split,
                );
            } else {
                state.splittingState.firstSplit = payload;
            }
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function getLocationTrackName(
    trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${trackNumber} ${prevStation.abbreviation}-${nextStation.abbreviation}`;
}

function getLocationTrackDescription(
    trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `Ratanumeron raide: ${trackNumber} ${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    fromStation: OperatingPoint | undefined,
    toStation: OperatingPoint | undefined,
    trackNumber: TrackNumber,
): { name: string; descriptionBase: string } {
    return {
        name:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackName(trackNumber, fromStation, toStation)
                : '',
        descriptionBase:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackDescription(trackNumber, fromStation, toStation)
                : '',
    };
}

function isSwitchSplit(split: SplitTargetCandidateBase): split is SplitTargetCandidate {
    return 'switchId' in split;
}

function findStationAtSwitchSplit(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    split: SplitTargetCandidate,
): OperatingPoint | undefined {
    return allowedSwitches.find((allowedSwitch) => allowedSwitch.switchId == split.switchId)
        ?.nearestOperatingPoint;
}

function findStation(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    nearestOperatingPointToStart: OperatingPoint | undefined,
    split: SplitTargetCandidateBase,
): OperatingPoint | undefined {
    return isSwitchSplit(split)
        ? findStationAtSwitchSplit(allowedSwitches, split)
        : nearestOperatingPointToStart;
}

function findNextStationAfterSplitIndex(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    nearestOperatingPointToEnd: OperatingPoint | undefined,
    splits: SplitTargetCandidate[],
    index: number,
): OperatingPoint | undefined {
    if (index === splits.length - 1 && splits.length > 0) {
        const lastSplit = splits[splits.length - 1];
        const lastSplitAllowedSwitchIndex = allowedSwitches.findIndex(
            (allowedSwitch) => allowedSwitch.switchId === lastSplit.switchId,
        );
        return lastSplitAllowedSwitchIndex == allowedSwitches.length - 1
            ? nearestOperatingPointToEnd
            : allowedSwitches[lastSplitAllowedSwitchIndex + 1].nearestOperatingPoint;
    } else {
        return index == splits.length - 1
            ? nearestOperatingPointToEnd
            : findStationAtSwitchSplit(allowedSwitches, splits[index + 1]);
    }
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.splits,
        splitState.firstSplit,
        splitState.trackNumber,
        splitState.nearestOperatingPointToStart,
        splitState.nearestOperatingPointToEnd,
        splitState.allowedSwitches,
    );
}
function updateAutogeneratedSplitNames(
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackNumber: TrackNumber,
    nearestOperatingPointToStart: OperatingPoint | undefined,
    nearestOperatingPointToEnd: OperatingPoint | undefined,
    allowedSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(
                      nearestOperatingPointToStart,
                      findStation(allowedSwitches, nearestOperatingPointToStart, splits[0]),
                      trackNumber,
                  ),
              }
            : firstSplit;

    const newSplits = splits.map((split, index) =>
        split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(
                      findStation(allowedSwitches, nearestOperatingPointToStart, split),
                      findNextStationAfterSplitIndex(
                          allowedSwitches,
                          nearestOperatingPointToEnd,
                          splits,
                          index,
                      ),
                      trackNumber,
                  ),
              }
            : split,
    );
    return { firstSplit: newFirstSplit, splits: newSplits };
}
