import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    DuplicateStatus,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
    SplitPoint,
    splitPointsAreSame,
    SwitchSplitPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicateTrack } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';
import { mapReducers } from 'map/map-store';
import { expectDefined } from 'utils/type-utils';
import { filterNotEmpty } from 'utils/array-utils';

export const PARTIAL_DUPLICATE_EXPECTED_MINIMUM_NON_OVERLAPPING_PART_LENGTH_METERS = 10;

export type SplitTargetDuplicateOperation = 'TRANSFER' | 'OVERWRITE';
export type SplitTargetOperation = SplitTargetDuplicateOperation | 'CREATE';

export type SplitTargetId = number;

type SplitTargetCandidateBase = {
    id: SplitTargetId;
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: DuplicateStatus | undefined;
    location: Point;
    focusBehaviour: SplitFocusBehaviour;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation;
    splitPoint: SplitPoint;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
};

export type SplitTarget = FirstSplitTargetCandidate | SplitTargetCandidate;

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    duplicateTracks: SplitDuplicateTrack[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    focusedSplit: SplitTargetId | undefined;
    highlightedSplit: SplitTargetId | undefined;
    highlightedSplitPoint: SplitPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    prefilledSplitPoints: SplitPoint[];
    duplicateTracks: SplitDuplicateTrack[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetDuplicateOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

type SplitFocusBehaviour = 'FOCUS' | 'NO_FOCUS';

let splitIdSequence = new Date().getTime();

function getNextSplitId(): number {
    return splitIdSequence++;
}

const findDuplicateStartingAt = (duplicates: SplitDuplicateTrack[], splitPoint: SplitPoint) => {
    return duplicates.find((duplicate) => {
        const duplicateSplitPoint = duplicate.status.startSplitPoint;
        return (
            duplicateSplitPoint != undefined && splitPointsAreSame(splitPoint, duplicateSplitPoint)
        );
    });
};

export function getAllowedSwitchesFromState(state: SplittingState) {
    const startSwitchId =
        state.startSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.startSplitPoint.switchId;
    const endSwitchId =
        state.endSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.endSplitPoint.switchId;
    return state.trackSwitches.filter(
        (sw) => sw.switchId != startSwitchId && sw.switchId != endSwitchId,
    );
}

const prefillSplits = (
    prefilledSplitPoints: SplitPoint[],
    switchesOnTrack: SwitchOnLocationTrack[],
    duplicateTracks: SplitDuplicateTrack[],
    originTrackId: LocationTrackId,
): SplitTargetCandidate[] =>
    prefilledSplitPoints
        .map((splitPoint) => {
            const sw = findSwitchForSplitPoint(switchesOnTrack, splitPoint);
            return sw?.location !== undefined &&
                sw?.distance !== undefined &&
                sw?.address !== undefined &&
                splitPoint.type === 'SWITCH_SPLIT_POINT'
                ? ([
                      SwitchSplitPoint(
                          sw.switchId,
                          splitPoint.name,
                          { ...sw.location, m: 0 },
                          sw.address,
                      ),
                      sw.location,
                      sw.distance,
                  ] as const)
                : undefined;
        })
        .filter(filterNotEmpty)
        .map(([splitPoint, location, distance]) =>
            splitPointToSplitTargetCandidate(
                duplicateTracks,
                originTrackId,
                location,
                distance,
                splitPoint,
                'NO_FOCUS',
            ),
        )
        .sort((a, b) => a.distance - b.distance);

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const locationTrackSelected = state.selection.selectedItems.locationTracks.some(
            (lt) => lt === payload.locationTrack.id,
        );

        if (locationTrackSelected) {
            const startSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.startSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.startSplitPoint.switchId,
            );
            const endSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.endSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.endSplitPoint.switchId,
            );
            const duplicateAtStart = findDuplicateStartingAt(
                payload.duplicateTracks,
                payload.startSplitPoint,
            );
            const nameAndDesc =
                duplicateAtStart?.name === undefined
                    ? ({
                          ...getNameForTarget(startSwitch, endSwitch),
                          hasAutogeneratedName: true,
                      } as const)
                    : ({
                          name: duplicateAtStart.name,
                          descriptionBase: '',
                          hasAutogeneratedName: false,
                      } as const);
            const firstSplit: FirstSplitTargetCandidate = {
                id: getNextSplitId(),
                ...nameAndDesc,
                type: 'FIRST_SPLIT',
                duplicateTrackId: duplicateAtStart?.id,
                duplicateStatus: duplicateAtStart?.status,
                suffixMode: 'NONE',
                location: payload.startLocation,
                focusBehaviour: 'FOCUS',
                distance: 0,
                splitPoint: payload.startSplitPoint,
                operation: getOperation(payload.locationTrack.id, duplicateAtStart?.status),
            } as const;
            const prefilledSplits = prefillSplits(
                payload.prefilledSplitPoints,
                payload.trackSwitches,
                payload.duplicateTracks,
                payload.locationTrack.id,
            );

            const prefilledSplitsNamed = updateAutogeneratedSplitNames(
                payload.startSplitPoint,
                payload.endSplitPoint,
                prefilledSplits,
                firstSplit,
                payload.trackSwitches,
            );

            state.layoutContext = draftLayoutContext(state.layoutContext);
            state.splittingState = {
                state: 'SETUP',
                originLocationTrack: payload.locationTrack,
                trackSwitches: payload.trackSwitches,
                duplicateTracks: payload.duplicateTracks,
                endLocation: payload.endLocation,
                disabled: payload.locationTrack.editState !== 'UNEDITED',
                trackNumber: payload.trackNumber,
                focusedSplit: undefined,
                highlightedSplit: undefined,
                highlightedSplitPoint: undefined,
                startSplitPoint: payload.startSplitPoint,
                endSplitPoint: payload.endSplitPoint,
                ...prefilledSplitsNamed,
            };

            mapReducers.showLayers(state.map, {
                payload: ['location-track-split-location-layer'],
                type: 'showLayers',
            });
        }
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        addSplitToState(state, splitPoint, 'FOCUS');
    },
    unfocusSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.splits = state.splittingState.splits.map((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint)
                    ? { ...split, focusBehaviour: 'NO_FOCUS' }
                    : split,
            );
            if (state.splittingState.firstSplit.focusBehaviour === 'FOCUS') {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    focusBehaviour: 'NO_FOCUS',
                };
            }
        }
    },
    removeSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            const splitToRemove = state.splittingState.splits.find((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint),
            );
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => !splitPointsAreSame(split.splitPoint, splitPoint),
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
                focusedSplit:
                    splitToRemove?.id === state.splittingState.focusedSplit
                        ? undefined
                        : state.splittingState.focusedSplit,
                highlightedSplit:
                    splitToRemove?.id === state.splittingState.highlightedSplit
                        ? undefined
                        : state.splittingState.highlightedSplit,
                highlightedSplitPoint:
                    splitPoint == state.splittingState.highlightedSplitPoint
                        ? undefined
                        : state.splittingState.highlightedSplitPoint,
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (split.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter(
                        (splitToCheck) =>
                            !splitPointsAreSame(split.splitPoint, splitToCheck.splitPoint),
                    )
                    .concat([split])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = split;
            }
        }
    },
    setHighlightedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplit = split;
        }
    },
    setFocusedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.focusedSplit = split;
        }
    },
    setHighlightedSplitPoint: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplitPoint = splitPoint;
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function getTrackNameFormattedSwitchName(switchName: string): string {
    // Example:
    // V0123 -> V123
    // <space><space><space>V0123<space><space> -> <space>V123<space>
    return switchName.replace(/\s+/g, ' ').replace(/V0(\d{3})/, 'V$1');
}

function getLocationTrackName(startSwitchName: string, endSwitchName: string): string {
    return `${getTrackNameFormattedSwitchName(startSwitchName)}-${getTrackNameFormattedSwitchName(
        endSwitchName,
    )}`;
}

const findSwitchForSplitPoint = (
    switchesOnLocationTrack: SwitchOnLocationTrack[],
    splitPoint: SplitPoint,
) =>
    switchesOnLocationTrack.find(
        (sw) => splitPoint.type === 'SWITCH_SPLIT_POINT' && sw.switchId === splitPoint.switchId,
    );

const isAlreadySplit = (existingSplits: SplitTargetCandidate[], splitPoint: SplitPoint) =>
    existingSplits.some((split) => splitPointsAreSame(splitPoint, split.splitPoint));

function splitPointToSplitTargetCandidate(
    duplicateTracks: SplitDuplicateTrack[],
    originLocationTrackId: LocationTrackId,
    switchLocation: Point,
    switchDistance: number,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour,
): SplitTargetCandidate {
    const duplicateAt = findDuplicateStartingAt(duplicateTracks, splitPoint);
    const name = duplicateAt?.name || '';

    return {
        id: getNextSplitId(),
        type: 'SPLIT',
        splitPoint: splitPoint,
        name,
        duplicateTrackId: duplicateAt?.id,
        duplicateStatus: duplicateAt?.status,
        descriptionBase: '',
        suffixMode: 'NONE',
        location: switchLocation,
        distance: switchDistance,
        focusBehaviour: splitFocusBehaviour,
        hasAutogeneratedName: name === '',
        operation: getOperation(originLocationTrackId, duplicateAt?.status),
    } as const;
}

function addSplitToState(
    state: TrackLayoutState,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour,
) {
    if (state.splittingState) {
        const switchForSplitPoint = findSwitchForSplitPoint(
            state.splittingState.trackSwitches,
            splitPoint,
        );

        if (
            splitPoint.type === 'SWITCH_SPLIT_POINT' &&
            !isAlreadySplit(state.splittingState.splits, splitPoint) &&
            switchForSplitPoint?.distance !== undefined &&
            switchForSplitPoint?.location !== undefined
        ) {
            const newSplit = splitPointToSplitTargetCandidate(
                state.splittingState.duplicateTracks,
                state.splittingState.originLocationTrack.id,
                switchForSplitPoint.location,
                switchForSplitPoint.distance,
                splitPoint,
                splitFocusBehaviour,
            );

            const newState = {
                ...state.splittingState,
                splits: [...state.splittingState.splits, newSplit]
                    .filter(filterNotEmpty)
                    .sort((a, b) => a.distance - b.distance),
            } as const;

            state.splittingState = {
                ...newState,
                ...updateAutogeneratedSplitNamesFromState(newState),
            } as const;
        }
    }
}

function getLocationTrackDescription(
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
): {
    name: string;
    descriptionBase: string;
} {
    return {
        name:
            startSwitch !== undefined && endSwitch !== undefined
                ? getLocationTrackName(startSwitch.name, endSwitch.name)
                : '',
        descriptionBase:
            startSwitch != undefined &&
            startSwitch.nearestOperatingPoint != undefined &&
            endSwitch != undefined &&
            endSwitch.nearestOperatingPoint != undefined &&
            startSwitch.nearestOperatingPoint.name != endSwitch.nearestOperatingPoint.name
                ? getLocationTrackDescription(
                      startSwitch.nearestOperatingPoint,
                      endSwitch.nearestOperatingPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.startSplitPoint,
        splitState.endSplitPoint,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackSwitches,
    );
}

function updateAutogeneratedSplitNames(
    startSplitPoint: SplitPoint | undefined,
    endSplitPoint: SplitPoint | undefined,
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = trackSwitches.find(
        (sw) =>
            startSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === startSplitPoint.switchId,
    );
    const firstSplitEndSplitPoint =
        splits.length > 0 ? expectDefined(splits[0]).splitPoint : endSplitPoint;
    const firstSplitEndSwitch = trackSwitches.find(
        (sw) =>
            firstSplitEndSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === firstSplitEndSplitPoint.switchId,
    );
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(firstSwitch, firstSplitEndSwitch),
              }
            : firstSplit;

    const endSwitch = trackSwitches.find(
        (sw) =>
            endSplitPoint?.type === 'SWITCH_SPLIT_POINT' && sw.switchId === endSplitPoint.switchId,
    );
    const newSplits = splits.map((split, index) => {
        const splitStartSwitch = trackSwitches.find(
            (sw) =>
                split.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                split.splitPoint.switchId === sw.switchId,
        );
        const nextSplit = index + 1 < splits.length ? splits[index + 1] : undefined;
        const splitEndSwitch = nextSplit
            ? trackSwitches.find(
                  (sw) =>
                      nextSplit.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                      nextSplit.splitPoint.switchId === sw.switchId,
              )
            : endSwitch;
        return split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(splitStartSwitch, splitEndSwitch),
              }
            : split;
    });
    return { firstSplit: newFirstSplit, splits: newSplits };
}
