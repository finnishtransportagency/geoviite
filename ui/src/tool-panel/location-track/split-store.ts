import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    DuplicateStatus,
    formatTrackName,
    getNameFreeText,
    getNameSpecifier,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    LocationTrackNameSpecifier,
    LocationTrackNamingScheme,
    OperationalPoint,
    SplitPoint,
    splitPointsAreSame,
    SwitchNameParts,
    SwitchSplitPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicateTrack } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';
import { mapReducers } from 'map/map-store';
import { expectDefined } from 'utils/type-utils';
import { filterNotEmpty } from 'utils/array-utils';
import { inferLayoutContextMode } from 'linking/linking-store';

export const PARTIAL_DUPLICATE_MINIMUM_VALIDATED_DIFFERENCE_METERS = 0.05;
export const PARTIAL_DUPLICATE_EXPECTED_MINIMUM_NON_OVERLAPPING_PART_LENGTH_METERS = 10;

export type SplitTargetDuplicateOperation = 'TRANSFER' | 'OVERWRITE';
export type SplitTargetOperation = SplitTargetDuplicateOperation | 'CREATE';

export type SplitTargetId = number;

type SplitTargetCandidateBase = {
    id: SplitTargetId;
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: DuplicateStatus | undefined;
    location: Point;
    focusBehaviour: SplitFocusBehaviour;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation;
    splitPoint: SplitPoint;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
};

export type SplitTarget = FirstSplitTargetCandidate | SplitTargetCandidate;

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    duplicateTracks: SplitDuplicateTrack[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    focusedSplit: SplitTargetId | undefined;
    highlightedSplit: SplitTargetId | undefined;
    highlightedSplitPoint: SplitPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    trackSwitches: SwitchOnLocationTrack[];
    startSplitPoint: SplitPoint;
    endSplitPoint: SplitPoint;
    prefilledSplitPoints: SplitPoint[];
    duplicateTracks: SplitDuplicateTrack[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    nameParts: SwitchNameParts;
    name: string;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperationalPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetDuplicateOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

type SplitFocusBehaviour = 'FOCUS' | 'NO_FOCUS';

let splitIdSequence = new Date().getTime();

function getNextSplitId(): number {
    return splitIdSequence++;
}

const findDuplicateStartingAt = (duplicates: SplitDuplicateTrack[], splitPoint: SplitPoint) => {
    return duplicates.find((duplicate) => {
        const duplicateSplitPoint = duplicate.status.startSplitPoint;
        return (
            duplicateSplitPoint !== undefined && splitPointsAreSame(splitPoint, duplicateSplitPoint)
        );
    });
};

export function getAllowedSwitchesFromState(state: SplittingState) {
    const startSwitchId =
        state.startSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.startSplitPoint.switchId;
    const endSwitchId =
        state.endSplitPoint.type === 'SWITCH_SPLIT_POINT' && state.endSplitPoint.switchId;
    return state.trackSwitches.filter(
        (sw) => sw.switchId !== startSwitchId && sw.switchId !== endSwitchId,
    );
}

const prefillSplits = (
    prefilledSplitPoints: SplitPoint[],
    switchesOnTrack: SwitchOnLocationTrack[],
    duplicateTracks: SplitDuplicateTrack[],
    originTrackId: LocationTrackId,
): SplitTargetCandidate[] =>
    prefilledSplitPoints
        .map((splitPoint) => {
            const sw = findSwitchForSplitPoint(switchesOnTrack, splitPoint);
            return sw?.location !== undefined &&
                sw?.distance !== undefined &&
                sw?.address !== undefined &&
                splitPoint.type === 'SWITCH_SPLIT_POINT'
                ? ([
                      SwitchSplitPoint(
                          sw.switchId,
                          splitPoint.name,
                          { ...sw.location, m: 0 },
                          sw.address,
                      ),
                      sw.location,
                      sw.distance,
                  ] as const)
                : undefined;
        })
        .filter(filterNotEmpty)
        .map(([splitPoint, location, distance]) =>
            splitPointToSplitTargetCandidate(
                duplicateTracks,
                originTrackId,
                location,
                distance,
                splitPoint,
                'NO_FOCUS',
            ),
        )
        .sort((a, b) => a.distance - b.distance);

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const locationTrackSelected = state.selection.selectedItems.locationTracks.some(
            (lt) => lt === payload.locationTrack.id,
        );

        if (locationTrackSelected) {
            const startSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.startSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.startSplitPoint.switchId,
            );
            const endSwitch = payload.trackSwitches.find(
                (sw) =>
                    payload.endSplitPoint.type === 'SWITCH_SPLIT_POINT' &&
                    sw.switchId === payload.endSplitPoint.switchId,
            );
            const duplicateAtStart = findDuplicateStartingAt(
                payload.duplicateTracks,
                payload.startSplitPoint,
            );
            const nameAndDesc =
                duplicateAtStart?.name === undefined
                    ? ({
                          ...getNameForTarget(payload.trackNumber, startSwitch, endSwitch),
                          hasAutogeneratedName: true,
                      } as const)
                    : ({
                          namingScheme: duplicateAtStart.nameStructure.scheme,
                          nameFreeText: getNameFreeText(duplicateAtStart?.nameStructure) ?? '',
                          nameSpecifier: getNameSpecifier(duplicateAtStart?.nameStructure),
                          name: duplicateAtStart.name,
                          descriptionBase: '',
                          hasAutogeneratedName: false,
                      } as const);
            const firstSplit: FirstSplitTargetCandidate = {
                id: getNextSplitId(),
                ...nameAndDesc,
                type: 'FIRST_SPLIT',
                duplicateTrackId: duplicateAtStart?.id,
                duplicateStatus: duplicateAtStart?.status,
                suffixMode: 'NONE',
                location: payload.startLocation,
                focusBehaviour: 'FOCUS',
                distance: 0,
                splitPoint: payload.startSplitPoint,
                operation: getOperation(payload.locationTrack.id, duplicateAtStart?.status),
            } as const;
            const prefilledSplits = prefillSplits(
                payload.prefilledSplitPoints,
                payload.trackSwitches,
                payload.duplicateTracks,
                payload.locationTrack.id,
            );

            const prefilledSplitsNamed = updateAutogeneratedSplitNames(
                payload.trackNumber,
                payload.startSplitPoint,
                payload.endSplitPoint,
                prefilledSplits,
                firstSplit,
                payload.trackSwitches,
            );

            const newLayoutContext = draftLayoutContext(state.layoutContext);
            state.layoutContext = newLayoutContext;
            state.layoutContextMode = inferLayoutContextMode(newLayoutContext);

            state.splittingState = {
                state: 'SETUP',
                originLocationTrack: payload.locationTrack,
                trackSwitches: payload.trackSwitches,
                duplicateTracks: payload.duplicateTracks,
                endLocation: payload.endLocation,
                disabled: payload.locationTrack.isDraft,
                trackNumber: payload.trackNumber,
                focusedSplit: undefined,
                highlightedSplit: undefined,
                highlightedSplitPoint: undefined,
                startSplitPoint: payload.startSplitPoint,
                endSplitPoint: payload.endSplitPoint,
                ...prefilledSplitsNamed,
            };

            mapReducers.showLayers(state.map, {
                payload: ['location-track-split-location-layer'],
                type: 'showLayers',
            });
        }
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        addSplitToState(state, splitPoint, 'FOCUS');
    },
    unfocusSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.splits = state.splittingState.splits.map((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint)
                    ? { ...split, focusBehaviour: 'NO_FOCUS' }
                    : split,
            );
            if (state.splittingState.firstSplit.focusBehaviour === 'FOCUS') {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    focusBehaviour: 'NO_FOCUS',
                };
            }
        }
    },
    removeSplit: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint>,
    ): void => {
        if (state.splittingState) {
            const splitToRemove = state.splittingState.splits.find((split) =>
                splitPointsAreSame(split.splitPoint, splitPoint),
            );
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter(
                    (split) => !splitPointsAreSame(split.splitPoint, splitPoint),
                ),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
                focusedSplit:
                    splitToRemove?.id === state.splittingState.focusedSplit
                        ? undefined
                        : state.splittingState.focusedSplit,
                highlightedSplit:
                    splitToRemove?.id === state.splittingState.highlightedSplit
                        ? undefined
                        : state.splittingState.highlightedSplit,
                highlightedSplitPoint:
                    splitPoint === state.splittingState.highlightedSplitPoint
                        ? undefined
                        : state.splittingState.highlightedSplitPoint,
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (split.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter(
                        (splitToCheck) =>
                            !splitPointsAreSame(split.splitPoint, splitToCheck.splitPoint),
                    )
                    .concat([split])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = split;
            }
        }
    },
    setHighlightedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplit = split;
        }
    },
    setFocusedSplit: (
        state: TrackLayoutState,
        { payload: split }: PayloadAction<SplitTargetId | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.focusedSplit = split;
        }
    },
    setHighlightedSplitPoint: (
        state: TrackLayoutState,
        { payload: splitPoint }: PayloadAction<SplitPoint | undefined>,
    ): void => {
        if (state.splittingState) {
            state.splittingState.highlightedSplitPoint = splitPoint;
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

const findSwitchForSplitPoint = (
    switchesOnLocationTrack: SwitchOnLocationTrack[],
    splitPoint: SplitPoint,
) =>
    switchesOnLocationTrack.find(
        (sw) => splitPoint.type === 'SWITCH_SPLIT_POINT' && sw.switchId === splitPoint.switchId,
    );

const isAlreadySplit = (existingSplits: SplitTargetCandidate[], splitPoint: SplitPoint) =>
    existingSplits.some((split) => splitPointsAreSame(splitPoint, split.splitPoint));

function splitPointToSplitTargetCandidate(
    duplicateTracks: SplitDuplicateTrack[],
    originLocationTrackId: LocationTrackId,
    switchLocation: Point,
    switchDistance: number,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour,
): SplitTargetCandidate {
    const duplicateAt = findDuplicateStartingAt(duplicateTracks, splitPoint);
    const name = duplicateAt?.name || '';

    return {
        id: getNextSplitId(),
        type: 'SPLIT',
        splitPoint: splitPoint,
        namingScheme: duplicateAt?.nameStructure?.scheme ?? LocationTrackNamingScheme.FREE_TEXT,
        nameFreeText: getNameFreeText(duplicateAt?.nameStructure),
        nameSpecifier: getNameSpecifier(duplicateAt?.nameStructure),
        name,
        duplicateTrackId: duplicateAt?.id,
        duplicateStatus: duplicateAt?.status,
        descriptionBase: '',
        suffixMode: 'NONE',
        location: switchLocation,
        distance: switchDistance,
        focusBehaviour: splitFocusBehaviour,
        hasAutogeneratedName: name === '',
        operation: getOperation(originLocationTrackId, duplicateAt?.status),
    } as const;
}

function addSplitToState(
    state: TrackLayoutState,
    splitPoint: SplitPoint,
    splitFocusBehaviour: SplitFocusBehaviour,
) {
    if (state.splittingState) {
        const switchForSplitPoint = findSwitchForSplitPoint(
            state.splittingState.trackSwitches,
            splitPoint,
        );

        if (
            splitPoint.type === 'SWITCH_SPLIT_POINT' &&
            !isAlreadySplit(state.splittingState.splits, splitPoint) &&
            switchForSplitPoint?.distance !== undefined &&
            switchForSplitPoint?.location !== undefined
        ) {
            const newSplit = splitPointToSplitTargetCandidate(
                state.splittingState.duplicateTracks,
                state.splittingState.originLocationTrack.id,
                switchForSplitPoint.location,
                switchForSplitPoint.distance,
                splitPoint,
                splitFocusBehaviour,
            );

            const newState = {
                ...state.splittingState,
                splits: [...state.splittingState.splits, newSplit]
                    .filter(filterNotEmpty)
                    .sort((a, b) => a.distance - b.distance),
            } as const;

            state.splittingState = {
                ...newState,
                ...updateAutogeneratedSplitNamesFromState(newState),
            } as const;
        }
    }
}

function getLocationTrackDescription(
    prevStation: OperationalPoint,
    nextStation: OperationalPoint,
): string {
    return `${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    trackNumber: TrackNumber,
    startSwitch: SwitchOnLocationTrack | undefined,
    endSwitch: SwitchOnLocationTrack | undefined,
): {
    namingScheme: LocationTrackNamingScheme;
    nameFreeText: string | undefined;
    nameSpecifier: LocationTrackNameSpecifier | undefined;
    name: string;
    descriptionBase: string;
} {
    // TODO: GVT-3083 when supporting other naming schemes, this should perhaps be BETWEEN_OPERATING_POINTS
    //  as within operating points the tracks mostly have duplicates to pick the name from.
    const namingScheme: LocationTrackNamingScheme = LocationTrackNamingScheme.FREE_TEXT;
    // TODO: GVT-3083 when supporting other naming schemes, it would likely make sense to pick this from the main track
    //  (the split source) as it will logically be on the same side as the split ones
    const nameSpecifier: LocationTrackNameSpecifier | undefined = undefined;
    const nameFreeText =
        startSwitch?.nameParts !== undefined && endSwitch?.nameParts !== undefined
            ? `${startSwitch.nameParts.prefix} ${startSwitch.nameParts.shortNumberPart}-${endSwitch.nameParts.prefix} ${endSwitch.nameParts.shortNumberPart}`
            : '';

    return {
        namingScheme,
        nameFreeText,
        nameSpecifier,
        name: formatTrackName(
            namingScheme,
            nameFreeText,
            nameSpecifier,
            trackNumber,
            startSwitch?.nameParts,
            endSwitch?.nameParts,
        ),
        descriptionBase:
            startSwitch !== undefined &&
            startSwitch.nearestOperatingPoint !== undefined &&
            endSwitch !== undefined &&
            endSwitch.nearestOperatingPoint !== undefined &&
            startSwitch.nearestOperatingPoint.name !== endSwitch.nearestOperatingPoint.name
                ? getLocationTrackDescription(
                      startSwitch.nearestOperatingPoint,
                      endSwitch.nearestOperatingPoint,
                  )
                : '',
    };
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.trackNumber,
        splitState.startSplitPoint,
        splitState.endSplitPoint,
        splitState.splits,
        splitState.firstSplit,
        splitState.trackSwitches,
    );
}

function updateAutogeneratedSplitNames(
    trackNumber: TrackNumber,
    startSplitPoint: SplitPoint | undefined,
    endSplitPoint: SplitPoint | undefined,
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const firstSwitch = trackSwitches.find(
        (sw) =>
            startSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === startSplitPoint.switchId,
    );
    const firstSplitEndSplitPoint =
        splits.length > 0 ? expectDefined(splits[0]).splitPoint : endSplitPoint;
    const firstSplitEndSwitch = trackSwitches.find(
        (sw) =>
            firstSplitEndSplitPoint?.type === 'SWITCH_SPLIT_POINT' &&
            sw.switchId === firstSplitEndSplitPoint.switchId,
    );
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(trackNumber, firstSwitch, firstSplitEndSwitch),
              }
            : firstSplit;

    const endSwitch = trackSwitches.find(
        (sw) =>
            endSplitPoint?.type === 'SWITCH_SPLIT_POINT' && sw.switchId === endSplitPoint.switchId,
    );
    const newSplits = splits.map((split, index) => {
        const splitStartSwitch = trackSwitches.find(
            (sw) =>
                split.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                split.splitPoint.switchId === sw.switchId,
        );
        const nextSplit = index + 1 < splits.length ? splits[index + 1] : undefined;
        const splitEndSwitch = nextSplit
            ? trackSwitches.find(
                  (sw) =>
                      nextSplit.splitPoint.type === 'SWITCH_SPLIT_POINT' &&
                      nextSplit.splitPoint.switchId === sw.switchId,
              )
            : endSwitch;
        return split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(trackNumber, splitStartSwitch, splitEndSwitch),
              }
            : split;
    });
    return { firstSplit: newFirstSplit, splits: newSplits };
}
