import { PayloadAction } from '@reduxjs/toolkit';
import {
    AlignmentPoint,
    LayoutLocationTrack,
    LayoutSwitchId,
    LocationTrackDescriptionSuffixMode,
    LocationTrackId,
    OperatingPoint,
} from 'track-layout/track-layout-model';
import { TrackLayoutState } from 'track-layout/track-layout-slice';
import { draftLayoutContext, TrackMeter, TrackNumber } from 'common/common-model';
import { Point } from 'model/geometry';
import { SplitDuplicate, SplitDuplicateStatus } from 'track-layout/layout-location-track-api';
import { getOperation } from './splitting/split-utils';

export type SplitTargetOperation = 'OVERWRITE' | 'TRANSFER';

type SplitTargetCandidateBase = {
    name: string;
    descriptionBase: string;
    suffixMode: LocationTrackDescriptionSuffixMode;
    duplicateTrackId: LocationTrackId | undefined;
    duplicateStatus: SplitDuplicateStatus | undefined;
    location: Point;
    new: boolean;
    hasAutogeneratedName: boolean;
    operation: SplitTargetOperation | undefined;
};

export type FirstSplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'FIRST_SPLIT';
    distance: 0;
    switchId: LayoutSwitchId | undefined;
};

export type SplitTargetCandidate = SplitTargetCandidateBase & {
    type: 'SPLIT';
    distance: number;
    switchId: LayoutSwitchId;
};

export type SplittingState = {
    state: 'SETUP' | 'POSTING';
    endLocation: AlignmentPoint;
    originLocationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
    disabled: boolean;
    trackNumber: TrackNumber;
    nearestOperatingPointToStart: OperatingPoint | undefined;
    nearestOperatingPointToEnd: OperatingPoint | undefined;
};

export type SplitStart = {
    locationTrack: LayoutLocationTrack;
    allowedSwitches: SwitchOnLocationTrack[];
    startAndEndSwitches: LayoutSwitchId[];
    duplicateTracks: SplitDuplicate[];
    startLocation: AlignmentPoint;
    endLocation: AlignmentPoint;
    trackNumber: TrackNumber;
    nearestOperatingPointToStart: OperatingPoint | undefined;
    nearestOperatingPointToEnd: OperatingPoint | undefined;
};

export type SwitchOnLocationTrack = {
    switchId: LayoutSwitchId;
    address: TrackMeter | undefined;
    location: Point | undefined;
    distance: number | undefined;
    nearestOperatingPoint: OperatingPoint | undefined;
};

export type SplitRequest = {
    sourceTrackId: LocationTrackId;
    targetTracks: SplitRequestTarget[];
};

export type SplitRequestTargetDuplicate = {
    id: LocationTrackId;
    operation: SplitTargetOperation;
};

export type SplitRequestTarget = {
    duplicateTrack: SplitRequestTargetDuplicate | undefined;
    startAtSwitchId: LayoutSwitchId | undefined;
    name: string;
    descriptionBase: string;
    descriptionSuffix: LocationTrackDescriptionSuffixMode;
};

const findDuplicateStartingAt = (duplicates: SplitDuplicate[], switchId: LayoutSwitchId) => {
    return duplicates.find((duplicate) => {
        return duplicate.status.startSwitchId === switchId;
    });
};

export const splitReducers = {
    onStartSplitting: (state: TrackLayoutState, { payload }: PayloadAction<SplitStart>): void => {
        const duplicateAtStart = findDuplicateStartingAt(
            payload.duplicateTracks,
            payload.startAndEndSwitches[0],
        );
        const nameAndDesc =
            duplicateAtStart?.name === undefined
                ? ({
                      ...getNameForTarget(
                          payload.nearestOperatingPointToStart,
                          payload.nearestOperatingPointToEnd,
                          payload.trackNumber,
                      ),
                      hasAutogeneratedName: true,
                  } as const)
                : ({
                      name: duplicateAtStart.name,
                      descriptionBase: '',
                      hasAutogeneratedName: false,
                  } as const);
        const firstSplit: FirstSplitTargetCandidate = {
            ...nameAndDesc,
            type: 'FIRST_SPLIT',
            duplicateTrackId: duplicateAtStart?.id,
            duplicateStatus: duplicateAtStart?.status,
            suffixMode: 'NONE',
            location: payload.startLocation,
            new: true,
            distance: 0,
            switchId: payload.startAndEndSwitches[0],
            operation: getOperation(
                payload.locationTrack.id,
                payload.startAndEndSwitches[0],
                duplicateAtStart?.status,
            ),
        } as const;
        state.layoutContext = draftLayoutContext(state.layoutContext);
        state.splittingState = {
            state: 'SETUP',
            originLocationTrack: payload.locationTrack,
            allowedSwitches: payload.allowedSwitches,
            startAndEndSwitches: payload.startAndEndSwitches,
            duplicateTracks: payload.duplicateTracks,
            splits: [],
            endLocation: payload.endLocation,
            disabled: payload.locationTrack.editState !== 'UNEDITED',
            firstSplit,
            trackNumber: payload.trackNumber,
            nearestOperatingPointToStart: payload.nearestOperatingPointToStart,
            nearestOperatingPointToEnd: payload.nearestOperatingPointToEnd,
        };
    },
    stopSplitting: (state: TrackLayoutState): void => {
        state.splittingState = undefined;
    },
    setDisabled: (state: TrackLayoutState, { payload }: PayloadAction<boolean>): void => {
        if (state.splittingState) {
            state.splittingState.disabled = payload;
        }
    },
    addSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        addSplitToState(state, payload);
    },
    markSplitOld: (
        state: TrackLayoutState,
        { payload }: PayloadAction<LayoutSwitchId | undefined>,
    ): void => {
        if (state.splittingState) {
            if (payload) {
                state.splittingState.splits = state.splittingState.splits.map((split) =>
                    split.switchId === payload ? { ...split, new: false } : split,
                );
            } else {
                state.splittingState.firstSplit = {
                    ...state.splittingState.firstSplit,
                    new: false,
                };
            }
        }
    },
    removeSplit: (state: TrackLayoutState, { payload }: PayloadAction<LayoutSwitchId>): void => {
        if (state.splittingState) {
            const newSplittingState: SplittingState = {
                ...state.splittingState,
                splits: state.splittingState.splits.filter((split) => split.switchId !== payload),
            };
            state.splittingState = {
                ...newSplittingState,
                ...updateAutogeneratedSplitNamesFromState(newSplittingState),
            };
        }
    },
    updateSplit: (
        state: TrackLayoutState,
        { payload }: PayloadAction<SplitTargetCandidate | FirstSplitTargetCandidate>,
    ): void => {
        if (state.splittingState) {
            if (payload.type === 'SPLIT') {
                state.splittingState.splits = state.splittingState.splits
                    .filter((split) => split.switchId !== payload.switchId)
                    .concat([payload])
                    .sort((a, b) => a.distance - b.distance);
            } else {
                state.splittingState.firstSplit = payload;
            }
        }
    },
    startPostingSplit: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'POSTING';
        }
    },
    returnToSplitting: (state: TrackLayoutState): void => {
        if (state.splittingState) {
            state.splittingState.state = 'SETUP';
        }
    },
};

function addSplitToState(state: TrackLayoutState, switchId: LayoutSwitchId) {
    const allowedSwitchIndex = state.splittingState?.allowedSwitches?.findIndex(
        (sw) => sw.switchId == switchId,
    );
    const isAlreadySplit = state.splittingState?.splits.some((s) => s.switchId === switchId);
    const allowedSwitch =
        allowedSwitchIndex === undefined
            ? undefined
            : state.splittingState?.allowedSwitches?.[allowedSwitchIndex];
    const allowedSwitchDistance = allowedSwitch?.distance;
    if (
        !isAlreadySplit &&
        state.splittingState &&
        !state.splittingState.disabled &&
        allowedSwitch?.location &&
        allowedSwitchDistance !== undefined &&
        !state.splittingState.splits.some((split) => split.switchId === switchId)
    ) {
        const duplicateAt = findDuplicateStartingAt(state.splittingState.duplicateTracks, switchId);
        const name = duplicateAt?.name || '';
        const newSplit: SplitTargetCandidate = {
            type: 'SPLIT',
            switchId: switchId,
            name,
            duplicateTrackId: duplicateAt?.id,
            duplicateStatus: duplicateAt?.status,
            descriptionBase: '',
            suffixMode: 'NONE',
            location: allowedSwitch.location,
            distance: allowedSwitchDistance,
            new: true,
            hasAutogeneratedName: name === '',
            operation: getOperation(
                state.splittingState.originLocationTrack.id,
                switchId,
                duplicateAt?.status,
            ),
        } as const;

        const newState = {
            ...state.splittingState,
            splits: state.splittingState.splits
                .concat([newSplit])
                .sort((a, b) => a.distance - b.distance),
        } as const;

        state.splittingState = {
            ...newState,
            ...updateAutogeneratedSplitNamesFromState(newState),
        } as const;

        // TODO: GVT-2552 this adds the end switch and recursively onwards.
        // Instead, a similar trick can be done from a separate user-action for all duplicates
        // if (duplicateAt && duplicateAt.status.endSwitchId !== undefined) {
        //     addSplitToState(state, duplicateAt.status.endSwitchId);
        // }
    }
}

function getLocationTrackName(
    trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `${trackNumber} ${prevStation.abbreviation}-${nextStation.abbreviation}`;
}

function getLocationTrackDescription(
    trackNumber: TrackNumber,
    prevStation: OperatingPoint,
    nextStation: OperatingPoint,
): string {
    return `Ratanumeron raide: ${trackNumber} ${prevStation.name}-${nextStation.name}`;
}

function getNameForTarget(
    fromStation: OperatingPoint | undefined,
    toStation: OperatingPoint | undefined,
    trackNumber: TrackNumber,
): { name: string; descriptionBase: string } {
    return {
        name:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackName(trackNumber, fromStation, toStation)
                : '',
        descriptionBase:
            fromStation != undefined && toStation != undefined && fromStation != toStation
                ? getLocationTrackDescription(trackNumber, fromStation, toStation)
                : '',
    };
}

function isSwitchSplit(split: SplitTargetCandidateBase): split is SplitTargetCandidate {
    return 'switchId' in split;
}

function findStationAtSwitchSplit(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    split: SplitTargetCandidate,
): OperatingPoint | undefined {
    return allowedSwitches.find((allowedSwitch) => allowedSwitch.switchId == split.switchId)
        ?.nearestOperatingPoint;
}

function findStation(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    nearestOperatingPointToStart: OperatingPoint | undefined,
    split: SplitTargetCandidateBase,
): OperatingPoint | undefined {
    return isSwitchSplit(split)
        ? findStationAtSwitchSplit(allowedSwitches, split)
        : nearestOperatingPointToStart;
}

function findNextStationAfterSplitIndex(
    allowedSwitches: readonly SwitchOnLocationTrack[],
    nearestOperatingPointToEnd: OperatingPoint | undefined,
    splits: SplitTargetCandidate[],
    index: number,
): OperatingPoint | undefined {
    if (index === splits.length - 1 && splits.length > 0) {
        const lastSplit = splits[splits.length - 1];
        const lastSplitAllowedSwitchIndex = allowedSwitches.findIndex(
            (allowedSwitch) => allowedSwitch.switchId === lastSplit.switchId,
        );
        return lastSplitAllowedSwitchIndex == allowedSwitches.length - 1
            ? nearestOperatingPointToEnd
            : allowedSwitches[lastSplitAllowedSwitchIndex + 1].nearestOperatingPoint;
    } else {
        return index == splits.length - 1
            ? nearestOperatingPointToEnd
            : findStationAtSwitchSplit(allowedSwitches, splits[index + 1]);
    }
}

function updateAutogeneratedSplitNamesFromState(splitState: SplittingState): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    return updateAutogeneratedSplitNames(
        splitState.splits,
        splitState.firstSplit,
        splitState.trackNumber,
        splitState.nearestOperatingPointToStart,
        splitState.nearestOperatingPointToEnd,
        splitState.allowedSwitches,
    );
}
function updateAutogeneratedSplitNames(
    splits: SplitTargetCandidate[],
    firstSplit: FirstSplitTargetCandidate,
    trackNumber: TrackNumber,
    nearestOperatingPointToStart: OperatingPoint | undefined,
    nearestOperatingPointToEnd: OperatingPoint | undefined,
    allowedSwitches: SwitchOnLocationTrack[],
): {
    firstSplit: FirstSplitTargetCandidate;
    splits: SplitTargetCandidate[];
} {
    const newFirstSplit =
        firstSplit.hasAutogeneratedName && splits.length > 0
            ? {
                  ...firstSplit,
                  ...getNameForTarget(
                      nearestOperatingPointToStart,
                      findStation(allowedSwitches, nearestOperatingPointToStart, splits[0]),
                      trackNumber,
                  ),
              }
            : firstSplit;

    const newSplits = splits.map((split, index) =>
        split.hasAutogeneratedName
            ? {
                  ...split,
                  ...getNameForTarget(
                      findStation(allowedSwitches, nearestOperatingPointToStart, split),
                      findNextStationAfterSplitIndex(
                          allowedSwitches,
                          nearestOperatingPointToEnd,
                          splits,
                          index,
                      ),
                      trackNumber,
                  ),
              }
            : split,
    );
    return { firstSplit: newFirstSplit, splits: newSplits };
}
